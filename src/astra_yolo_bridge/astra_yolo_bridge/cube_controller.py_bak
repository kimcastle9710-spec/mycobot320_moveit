#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from geometry_msgs.msg import PoseStamped, Point, Quaternion, Pose
from moveit_msgs.action import MoveGroup
from moveit_msgs.msg import Constraints, JointConstraint, PositionConstraint, OrientationConstraint
from shape_msgs.msg import SolidPrimitive
from tf2_ros import Buffer, TransformListener
import time

# # ë¡œë´‡ ê´€ì ˆ ì´ë¦„ (MyCobot í‘œì¤€)
# JOINT_NAMES = ['joint1', 'joint2', 'joint3', 'joint4', 'joint5', 'joint6']
# [ìˆ˜ì •] ì§„ì§œ ê´€ì ˆ ì´ë¦„ ë¦¬ìŠ¤íŠ¸
JOINT_NAMES = [
    'joint2_to_joint1',
    'joint3_to_joint2',
    'joint4_to_joint3',
    'joint5_to_joint4',
    'joint6_to_joint5',
    'joint6output_to_joint6'
]
class CubeController(Node):
    def __init__(self):
        super().__init__('cube_controller')
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)
        self._action_client = ActionClient(self, MoveGroup, 'move_action')

        # ìƒíƒœ ê´€ë¦¬ (0:ëŒ€ê¸°, 1:íë¸Œì´ë™ì¤‘, 2:í™ˆì´ë™ì¤‘)
        self.state = 0 
        self.get_logger().info("Waiting for MoveGroup...")
        self._action_client.wait_for_server()
        self.get_logger().info("âœ… Ready! Loop: Cube -> Home -> Cube...")

        # 1ì´ˆë§ˆë‹¤ ìƒíƒœë¥¼ ì²´í¬í•´ì„œ ë‹¤ìŒ í–‰ë™ì„ ê²°ì •í•©ë‹ˆë‹¤.
        self.timer = self.create_timer(1.0, self.control_loop)

    def control_loop(self):
        # ìƒíƒœ 0: íë¸Œ ì°¾ê³  ì´ë™ ëª…ë ¹ ë‚´ë¦¬ê¸°
        if self.state == 0:
            self.find_and_move_to_cube()
        
        # ìƒíƒœ 10: í™ˆìœ¼ë¡œ ì´ë™ ëª…ë ¹ ë‚´ë¦¬ê¸° (íë¸Œ ì¡ì€ í›„)
        elif self.state == 10:
            self.move_to_home()

    # def find_and_move_to_cube(self):
    #     try:
    #         trans = self.tf_buffer.lookup_transform('base', 'cube_target', rclpy.time.Time())
    #     except Exception:
    #         self.get_logger().warn("ğŸ” Searching for cube...")
    #         return

    #     # íë¸Œ ë°œê²¬!
    #     x = trans.transform.translation.x
    #     y = trans.transform.translation.y
    #     # [ì¤‘ìš”] ê·¸ë¦¬í¼ ê¸¸ì´ ê³ ë ¤ (20cm ìœ„) - í•„ìš”ì‹œ ì¡°ì ˆí•˜ì„¸ìš” (0.18 ~ 0.22)
    #     z = trans.transform.translation.z + 0.20 

    #     self.get_logger().info(f"ğŸ“ Cube Found! Moving to X={x:.2f}, Y={y:.2f}, Z={z:.2f}")
        
    #     # ì´ë™ ëª…ë ¹ ì „ì†¡
    #     if self.send_pose_goal(x, y, z):
    #         self.state = 1 # ì´ë™ ì¤‘ ìƒíƒœë¡œ ë³€ê²½ (ì¤‘ë³µ ëª…ë ¹ ë°©ì§€)

# [ìˆ˜ì •] íë¸Œ ì ‘ê·¼ ë° ê·¸ë¦½ ë™ì‘ ë¶„ë¦¬
    def find_and_move_to_cube(self):
        try:
            trans = self.tf_buffer.lookup_transform('base', 'cube_target', rclpy.time.Time())
        except Exception:
            self.get_logger().warn("ğŸ” Searching for cube...")
            return

        x = trans.transform.translation.x
        y = trans.transform.translation.y
        z_target = trans.transform.translation.z
        
        # [1ë‹¨ê³„] íë¸Œ ìœ„ 25cm ì§€ì ê¹Œì§€ ë¨¼ì € ì´ë™ (ì ‘ê·¼ ëŒ€ê¸°)
        z_hover = z_target + 0.25
        self.get_logger().info(f"ğŸš Hovering above cube...")
        if not self.send_pose_goal(x, y, z_hover):
            return # ì‹¤íŒ¨í•˜ë©´ ì¤‘ë‹¨

        time.sleep(0.5) # ì ì‹œ ì•ˆì •í™”

        # [2ë‹¨ê³„] íë¸Œ ì¡ëŠ” ìœ„ì¹˜(ì˜ˆ: 18cm)ë¡œ ìˆ˜ì§ í•˜ê°•
        z_grip = z_target + 0.18 # ë†’ì´ ì¡°ì ˆ í•„ìš”
        self.get_logger().info(f"â¬‡ï¸ Descending to grip...")
        if self.send_pose_goal(x, y, z_grip):
            self.state = 1 # ì„±ê³µ ì‹œ ë‹¤ìŒ ë‹¨ê³„ë¡œ









    # def move_to_home(self):
    #     self.get_logger().info("ğŸ  Going Home...")
    #     if self.send_joint_goal([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]):
    #         self.state = 2 # í™ˆ ì´ë™ ì¤‘
    def move_to_home(self):
        self.get_logger().info("ğŸ  Going Home...")
        
        # í™ˆ ìœ„ì¹˜ (ëª¨ë“  ê´€ì ˆ 0ë„)
        home_joints = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        
        # 'send_joint_goal' í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì„œ ì´ë™ ëª…ë ¹ì„ ë‚´ë¦½ë‹ˆë‹¤.
        if self.send_joint_goal(home_joints):
            self.state = 2 # í™ˆ ì´ë™ ì¤‘ ìƒíƒœë¡œ ë³€ê²½
    def send_pose_goal(self, x, y, z):
        goal_msg = MoveGroup.Goal()
        goal_msg.request.group_name = 'arm'
        goal_msg.request.num_planning_attempts = 10
        goal_msg.request.allowed_planning_time = 5.0
        goal_msg.request.max_velocity_scaling_factor = 0.5
        goal_msg.request.max_acceleration_scaling_factor = 0.5

        # ìœ„ì¹˜ ì œì•½
        pcm = PositionConstraint()
        pcm.header.frame_id = 'base'
        pcm.link_name = 'link6'
        pcm.weight = 1.0
        target_pose = Pose()
        target_pose.position.x = x
        target_pose.position.y = y
        target_pose.position.z = z
        target_pose.orientation.w = 1.0
        pcm.constraint_region.primitives = [SolidPrimitive(type=SolidPrimitive.SPHERE, dimensions=[0.01])]
        pcm.constraint_region.primitive_poses = [target_pose]

        # ë°©í–¥ ì œì•½ (ì•„ë˜ ë³´ê¸°)
        ocm = OrientationConstraint()
        ocm.header.frame_id = 'base'
        ocm.link_name = 'link6'
        ocm.orientation = Quaternion(x=1.0, y=0.0, z=0.0, w=0.0)
        ocm.absolute_x_axis_tolerance = 0.1 # ê´€ëŒ€í•˜ê²Œ
        ocm.absolute_y_axis_tolerance = 0.1
        ocm.absolute_z_axis_tolerance = 3.14 # íšŒì „ ììœ 
        ocm.weight = 1.0

        goal_msg.request.goal_constraints.append(Constraints(position_constraints=[pcm], orientation_constraints=[ocm]))
        
        future = self._action_client.send_goal_async(goal_msg)
        future.add_done_callback(self.cube_done_cb)
        return True

    def send_joint_goal(self, joints):
        goal_msg = MoveGroup.Goal()
        goal_msg.request.group_name = 'arm'
        goal_msg.request.num_planning_attempts = 10
        goal_msg.request.max_velocity_scaling_factor = 0.5
        goal_msg.request.max_acceleration_scaling_factor = 0.5

        jc_list = []
        for i, val in enumerate(joints):
            jc = JointConstraint()
            jc.joint_name = JOINT_NAMES[i]
            jc.position = val
            jc.tolerance_above = 0.01
            jc.tolerance_below = 0.01
            jc.weight = 1.0
            jc_list.append(jc)

        goal_msg.request.goal_constraints.append(Constraints(joint_constraints=jc_list))
        
        future = self._action_client.send_goal_async(goal_msg)
        future.add_done_callback(self.home_done_cb)
        return True

    def cube_done_cb(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.state = 0 # ì‹¤íŒ¨í•˜ë©´ ë‹¤ì‹œ ê²€ìƒ‰
            return
        
        # ì´ë™ì´ ëë‚˜ë©´ ê²°ê³¼ ë°›ê¸°
        res_future = goal_handle.get_result_async()
        res_future.add_done_callback(self.cube_arrived)

    def cube_arrived(self, future):
        # íë¸Œ ë„ì°© ì™„ë£Œ!
        self.get_logger().info("ğŸ“¦ Arrived at Cube! (Gripping...)")
        time.sleep(2.0) # ì¡ëŠ” ì²™ (2ì´ˆ ëŒ€ê¸°)
        self.state = 10 # ë‹¤ìŒ ë‹¨ê³„: í™ˆìœ¼ë¡œ ê°€ë¼!

    def home_done_cb(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.state = 10 # ì‹¤íŒ¨í•˜ë©´ ë‹¤ì‹œ í™ˆ ì‹œë„
            return
        res_future = goal_handle.get_result_async()
        res_future.add_done_callback(self.home_arrived)

    def home_arrived(self, future):
        # í™ˆ ë„ì°© ì™„ë£Œ!
        self.get_logger().info("ğŸ  Arrived Home! Restarting...")
        time.sleep(1.0)
        self.state = 0 # ë‹¤ì‹œ ì²˜ìŒ(íë¸Œ ê²€ìƒ‰)ìœ¼ë¡œ ë¦¬ì…‹!

def main():
    rclpy.init()
    node = CubeController()
    rclpy.spin(node)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
